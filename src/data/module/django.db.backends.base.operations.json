{
  "functions": [],
  "classes": [
    {
      "name": "BaseDatabaseOperations",
      "methods": [
        {
          "name": "autoinc_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "table",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "column",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return any SQL needed to support auto-incrementing primary keys, or\n        None if no SQL is necessary.\n\n        This SQL is executed when a table is created.\n        \"\"\""
        },
        {
          "name": "bulk_batch_size",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "fields",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "objs",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the maximum allowed batch size for the backend. The fields\n        are the fields going to be inserted in the batch, the objs contains\n        all the objects to be inserted.\n        \"\"\""
        },
        {
          "name": "cache_key_culling_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return an SQL query that retrieves the first cache key greater than the\n        n smallest.\n\n        This is used by the 'db' cache backend to determine where to start\n        culling.\n        \"\"\""
        },
        {
          "name": "unification_cast_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "output_field",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Given a field instance, return the SQL that casts the result of a union\n        to that type. The resulting string should contain a '%s' placeholder\n        for the expression being cast.\n        \"\"\""
        },
        {
          "name": "date_extract_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "lookup_type",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "field_name",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Given a lookup_type of 'year', 'month', or 'day', return the SQL that\n        extracts a value from the given date field field_name.\n        \"\"\""
        },
        {
          "name": "date_trunc_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "lookup_type",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "field_name",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "tzname",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Given a lookup_type of 'year', 'month', or 'day', return the SQL that\n        truncates the given date or datetime field field_name to a date object\n        with only the given specificity.\n\n        If `tzname` is provided, the given value is truncated in a specific\n        timezone.\n        \"\"\""
        },
        {
          "name": "datetime_cast_date_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "field_name",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "tzname",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the SQL to cast a datetime value to date value.\n        \"\"\""
        },
        {
          "name": "datetime_cast_time_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "field_name",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "tzname",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the SQL to cast a datetime value to time value.\n        \"\"\""
        },
        {
          "name": "datetime_extract_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "lookup_type",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "field_name",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "tzname",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Given a lookup_type of 'year', 'month', 'day', 'hour', 'minute', or\n        'second', return the SQL that extracts a value from the given\n        datetime field field_name.\n        \"\"\""
        },
        {
          "name": "datetime_trunc_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "lookup_type",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "field_name",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "tzname",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Given a lookup_type of 'year', 'month', 'day', 'hour', 'minute', or\n        'second', return the SQL that truncates the given datetime field\n        field_name to a datetime object with only the given specificity.\n        \"\"\""
        },
        {
          "name": "time_trunc_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "lookup_type",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "field_name",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "tzname",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Given a lookup_type of 'hour', 'minute' or 'second', return the SQL\n        that truncates the given time or datetime field field_name to a time\n        object with only the given specificity.\n\n        If `tzname` is provided, the given value is truncated in a specific\n        timezone.\n        \"\"\""
        },
        {
          "name": "time_extract_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "lookup_type",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "field_name",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Given a lookup_type of 'hour', 'minute', or 'second', return the SQL\n        that extracts a value from the given time field field_name.\n        \"\"\""
        },
        {
          "name": "deferrable_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the SQL to make a constraint \"initially deferred\" during a\n        CREATE TABLE statement.\n        \"\"\""
        },
        {
          "name": "distinct_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "fields",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "params",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return an SQL DISTINCT clause which removes duplicate rows from the\n        result set. If any fields are given, only check the given fields for\n        duplicates.\n        \"\"\""
        },
        {
          "name": "fetch_returned_insert_columns",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "cursor",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "returning_params",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Given a cursor object that has just performed an INSERT...RETURNING\n        statement into a table, return the newly created data.\n        \"\"\""
        },
        {
          "name": "field_cast_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "db_type",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "internal_type",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Given a column type (e.g. 'BLOB', 'VARCHAR') and an internal type\n        (e.g. 'GenericIPAddressField'), return the SQL to cast it before using\n        it in a WHERE statement. The resulting string should contain a '%s'\n        placeholder for the column being searched against.\n        \"\"\""
        },
        {
          "name": "force_no_ordering",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return a list used in the \"ORDER BY\" clause to force no ordering at\n        all. Return an empty list to include nothing in the ordering.\n        \"\"\""
        },
        {
          "name": "for_update_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "nowait",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "skip_locked",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "of",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "no_key",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the FOR UPDATE SQL clause to lock rows for an update operation.\n        \"\"\""
        },
        {
          "name": "limit_offset_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "low_mark",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "high_mark",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"Return LIMIT/OFFSET SQL clause.\"\"\""
        },
        {
          "name": "last_executed_query",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "cursor",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "sql",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "params",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return a string of the query last executed by the given cursor, with\n        placeholders replaced with actual values.\n\n        `sql` is the raw query containing placeholders and `params` is the\n        sequence of parameters. These are used by default, but this method\n        exists for database backends to provide a better implementation\n        according to their own quoting schemes.\n        \"\"\""
        },
        {
          "name": "last_insert_id",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "cursor",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "table_name",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "pk_name",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Given a cursor object that has just performed an INSERT statement into\n        a table that has an auto-incrementing ID, return the newly created ID.\n\n        `pk_name` is the name of the primary-key column.\n        \"\"\""
        },
        {
          "name": "lookup_cast",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "lookup_type",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "internal_type",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the string to use in a query when performing lookups\n        (\"contains\", \"like\", etc.). It should contain a '%s' placeholder for\n        the column being searched against.\n        \"\"\""
        },
        {
          "name": "max_in_list_size",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the maximum number of items that can be passed in a single 'IN'\n        list condition, or None if the backend does not impose a limit.\n        \"\"\""
        },
        {
          "name": "max_name_length",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the maximum length of table and column names, or None if there\n        is no limit.\n        \"\"\""
        },
        {
          "name": "no_limit_value",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the value to use for the LIMIT when we are wanting \"LIMIT\n        infinity\". Return None if the limit clause can be omitted in this case.\n        \"\"\""
        },
        {
          "name": "pk_default_value",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the value to use during an INSERT statement to specify that\n        the field should use its default value.\n        \"\"\""
        },
        {
          "name": "prepare_sql_script",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "sql",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Take an SQL script that may contain multiple lines and return a list\n        of statements to feed to successive cursor.execute() calls.\n\n        Since few databases are able to process raw SQL scripts in a single\n        cursor.execute() call and PEP 249 doesn't talk about this use case,\n        the default implementation is conservative.\n        \"\"\""
        },
        {
          "name": "process_clob",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "value",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the value of a CLOB column, for backends that return a locator\n        object that requires additional processing.\n        \"\"\""
        },
        {
          "name": "return_insert_columns",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "fields",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        For backends that support returning columns as part of an insert query,\n        return the SQL and params to append to the INSERT query. The returned\n        fragment should contain a format string to hold the appropriate column.\n        \"\"\""
        },
        {
          "name": "compiler",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "compiler_name",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the SQLCompiler class corresponding to the given name,\n        in the namespace corresponding to the `compiler_module` attribute\n        on this backend.\n        \"\"\""
        },
        {
          "name": "quote_name",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "name",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return a quoted version of the given table, index, or column name. Do\n        not quote the given name if it's already been quoted.\n        \"\"\""
        },
        {
          "name": "regex_lookup",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "lookup_type",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the string to use in a query when performing regular expression\n        lookups (using \"regex\" or \"iregex\"). It should contain a '%s'\n        placeholder for the column being searched against.\n\n        If the feature is not supported (or part of it is not supported), raise\n        NotImplementedError.\n        \"\"\""
        },
        {
          "name": "savepoint_create_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "sid",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the SQL for starting a new savepoint. Only required if the\n        \"uses_savepoints\" feature is True. The \"sid\" parameter is a string\n        for the savepoint id.\n        \"\"\""
        },
        {
          "name": "savepoint_commit_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "sid",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the SQL for committing the given savepoint.\n        \"\"\""
        },
        {
          "name": "savepoint_rollback_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "sid",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the SQL for rolling back the given savepoint.\n        \"\"\""
        },
        {
          "name": "set_time_zone_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the SQL that will set the connection's time zone.\n\n        Return '' if the backend doesn't support time zones.\n        \"\"\""
        },
        {
          "name": "sql_flush",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "style",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "tables",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "reset_sequences",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "allow_cascade",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return a list of SQL statements required to remove all data from\n        the given database tables (without actually removing the tables\n        themselves).\n\n        The `style` argument is a Style object as returned by either\n        color_style() or no_style() in django.core.management.color.\n\n        If `reset_sequences` is True, the list includes SQL statements required\n        to reset the sequences.\n\n        The `allow_cascade` argument determines whether truncation may cascade\n        to tables with foreign keys pointing the tables being truncated.\n        PostgreSQL requires a cascade even if these tables are empty.\n        \"\"\""
        },
        {
          "name": "execute_sql_flush",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "sql_list",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"Execute a list of SQL statements to flush the database.\"\"\""
        },
        {
          "name": "sequence_reset_by_name_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "style",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "sequences",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return a list of the SQL statements required to reset sequences\n        passed in `sequences`.\n\n        The `style` argument is a Style object as returned by either\n        color_style() or no_style() in django.core.management.color.\n        \"\"\""
        },
        {
          "name": "sequence_reset_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "style",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "model_list",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return a list of the SQL statements required to reset sequences for\n        the given models.\n\n        The `style` argument is a Style object as returned by either\n        color_style() or no_style() in django.core.management.color.\n        \"\"\""
        },
        {
          "name": "start_transaction_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"Return the SQL statement required to start a transaction.\"\"\""
        },
        {
          "name": "end_transaction_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "success",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"Return the SQL statement required to end a transaction.\"\"\""
        },
        {
          "name": "tablespace_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "tablespace",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "inline",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return the SQL that will be used in a query to define the tablespace.\n\n        Return '' if the backend doesn't support tablespaces.\n\n        If `inline` is True, append the SQL to a row; otherwise append it to\n        the entire CREATE TABLE or CREATE INDEX statement.\n        \"\"\""
        },
        {
          "name": "prep_for_like_query",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "x",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"Prepare a value for use in a LIKE query.\"\"\""
        },
        {
          "name": "validate_autopk_value",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "value",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Certain backends do not accept some values for \"serial\" fields\n        (for example zero in MySQL). Raise a ValueError if the value is\n        invalid, otherwise return the validated value.\n        \"\"\""
        },
        {
          "name": "adapt_unknown_value",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "value",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Transform a value to something compatible with the backend driver.\n\n        This method only depends on the type of the value. It's designed for\n        cases where the target type isn't known, such as .raw() SQL queries.\n        As a consequence it may not work perfectly in all circumstances.\n        \"\"\""
        },
        {
          "name": "adapt_datefield_value",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "value",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Transform a date value to an object compatible with what is expected\n        by the backend driver for date columns.\n        \"\"\""
        },
        {
          "name": "adapt_datetimefield_value",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "value",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Transform a datetime value to an object compatible with what is expected\n        by the backend driver for datetime columns.\n        \"\"\""
        },
        {
          "name": "adapt_timefield_value",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "value",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Transform a time value to an object compatible with what is expected\n        by the backend driver for time columns.\n        \"\"\""
        },
        {
          "name": "adapt_decimalfield_value",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "value",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "max_digits",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "decimal_places",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Transform a decimal.Decimal value to an object compatible with what is\n        expected by the backend driver for decimal (numeric) columns.\n        \"\"\""
        },
        {
          "name": "adapt_ipaddressfield_value",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "value",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Transform a string representation of an IP address into the expected\n        type for the backend driver.\n        \"\"\""
        },
        {
          "name": "year_lookup_bounds_for_date_field",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "value",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "iso_year",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return a two-elements list with the lower and upper bound to be used\n        with a BETWEEN operator to query a DateField value using a year\n        lookup.\n\n        `value` is an int, containing the looked-up year.\n        If `iso_year` is True, return bounds for ISO-8601 week-numbering years.\n        \"\"\""
        },
        {
          "name": "year_lookup_bounds_for_datetime_field",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "value",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "iso_year",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return a two-elements list with the lower and upper bound to be used\n        with a BETWEEN operator to query a DateTimeField value using a year\n        lookup.\n\n        `value` is an int, containing the looked-up year.\n        If `iso_year` is True, return bounds for ISO-8601 week-numbering years.\n        \"\"\""
        },
        {
          "name": "get_db_converters",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "expression",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return a list of functions needed to convert field data.\n\n        Some field types on some backends do not provide data in the correct\n        format, this is the hook for converter functions.\n        \"\"\""
        },
        {
          "name": "convert_durationfield_value",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "value",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "expression",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "connection",
              "annotation": null
            }
          ]
        },
        {
          "name": "check_expression_support",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "expression",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Check that the backend supports the provided expression.\n\n        This is used on specific backends to rule out known expressions\n        that have problematic or nonexistent implementations. If the\n        expression has a known problem, the backend should raise\n        NotSupportedError.\n        \"\"\""
        },
        {
          "name": "conditional_expression_supported_in_where_clause",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "expression",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return True, if the conditional expression is supported in the WHERE\n        clause.\n        \"\"\""
        },
        {
          "name": "combine_expression",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "connector",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "sub_expressions",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Combine a list of subexpressions into a single expression, using\n        the provided connecting operator. This is required because operators\n        can vary between backends (e.g., Oracle with %% and &) and between\n        subexpression types (e.g., date expressions).\n        \"\"\""
        },
        {
          "name": "combine_duration_expression",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "connector",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "sub_expressions",
              "annotation": null
            }
          ]
        },
        {
          "name": "binary_placeholder_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "value",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Some backends require special syntax to insert binary content (MySQL\n        for example uses '_binary %s').\n        \"\"\""
        },
        {
          "name": "modify_insert_params",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "placeholder",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "params",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Allow modification of insert parameters. Needed for Oracle Spatial\n        backend due to #10888.\n        \"\"\""
        },
        {
          "name": "integer_field_range",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "internal_type",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Given an integer field internal type (e.g. 'PositiveIntegerField'),\n        return a tuple of the (min_value, max_value) form representing the\n        range of the column type bound to the field.\n        \"\"\""
        },
        {
          "name": "subtract_temporals",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "internal_type",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "lhs",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "rhs",
              "annotation": null
            }
          ]
        },
        {
          "name": "window_frame_start",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "start",
              "annotation": null
            }
          ]
        },
        {
          "name": "window_frame_end",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "end",
              "annotation": null
            }
          ]
        },
        {
          "name": "window_frame_rows_start_end",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "start",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "end",
              "annotation": null
            }
          ],
          "docstring": "\"\"\"\n        Return SQL for start and end points in an OVER clause window frame.\n        \"\"\""
        },
        {
          "name": "window_frame_range_start_end",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "start",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "end",
              "annotation": null
            }
          ]
        },
        {
          "name": "explain_query_prefix",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "format",
              "annotation": null
            },
            {
              "prefix": "**",
              "name": "options",
              "annotation": null
            }
          ]
        },
        {
          "name": "insert_statement",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "ignore_conflicts",
              "annotation": null
            }
          ]
        },
        {
          "name": "ignore_conflicts_suffix_sql",
          "params": [
            {
              "prefix": "",
              "name": "self",
              "annotation": null
            },
            {
              "prefix": "",
              "name": "ignore_conflicts",
              "annotation": null
            }
          ]
        }
      ],
      "classes": [],
      "docstring": "\"\"\"\n    Encapsulate backend-specific differences, such as the way a backend\n    performs ordering or calculates the ID of a recently-inserted row.\n    \"\"\""
    }
  ]
}